from flask import Flask, render_template, request, jsonify
import requests
from bs4 import BeautifulSoup
import re
import json
from datetime import datetime
import os
from dotenv import load_dotenv

# Загружаем переменные окружения
load_dotenv()

app = Flask(__name__)

# HuggingChat настройки
HUGGINGCHAT_URL = "https://huggingface.co/chat"
HUGGINGCHAT_API_URL = "https://huggingface.co/chat/conversation"

# Sherlock Holmes persona
SHERLOCK_PROMPT = """Ты - Шерлок Холмс, знаменитый детектив-консультант из Лондона. 
Ты известен своим дедуктивным методом, острым умом и способностью замечать мельчайшие детали.

Твои характеристики:
- Ты живешь на Бейкер-стрит, 221Б
- Твой лучший друг и помощник - доктор Джон Ватсон
- Ты играешь на скрипке и употребляешь кокаин
- Ты презираешь эмоции и полагаешься только на логику
- Ты говоришь с британским акцентом и используешь формальный язык
- Ты часто используешь фразы "Элементарно, мой дорогой Ватсон" и "Когда ты исключишь невозможное..."

Отвечай в стиле Шерлока Холмса, используя дедуктивный метод и логические рассуждения.
Всегда будь вежлив, но немного высокомерен в своем интеллектуальном превосходстве.

Контекст из веб-страниц: {context}

Вопрос: {question}

Ответ Шерлока Холмса:"""

# Глобальные переменные для хранения скрапленного контента
scraped_content = []

def generate_response(question, context=""):
    """Генерация ответа с использованием HuggingChat или fallback"""
    try:
        # Формируем промпт в стиле Шерлока
        prompt = SHERLOCK_PROMPT.format(context=context, question=question)
        
        # Пытаемся использовать HuggingChat (через веб-интерфейс)
        response = try_huggingchat_generation(prompt)
        
        if response and response != "error":
            return response
        else:
            # Fallback на предустановленные ответы
            return generate_fallback_response(question, context)
        
    except Exception as e:
        print(f"Ошибка генерации: {e}")
        return generate_fallback_response(question, context)

def try_huggingchat_generation(prompt):
    """Попытка генерации через HuggingChat веб-интерфейс"""
    try:
        # Это упрощенная версия - в реальности нужно использовать API HuggingChat
        # или интегрироваться через их веб-интерфейс
        return "error"  # Пока возвращаем ошибку, так как нужна более сложная интеграция
    except Exception as e:
        print(f"Ошибка HuggingChat: {e}")
        return "error"

def generate_fallback_response(question, context=""):
    """Генерация ответа без API ключа, используя предустановленные ответы"""
    question_lower = question.lower()
    
    # Расширенный анализ ключевых слов
    keywords = {
        'greeting': ['привет', 'здравствуй', 'добрый день', 'hello', 'hi', 'доброе утро', 'добрый вечер'],
        'status': ['как дела', 'как ты', 'как поживаешь', 'как жизнь'],
        'identity': ['кто ты', 'расскажи о себе', 'представься', 'твое имя'],
        'help': ['помощь', 'что умеешь', 'возможности', 'функции', 'команды'],
        'mystery': ['загадка', 'задача', 'проблема', 'дело', 'случай'],
        'method': ['логика', 'дедукция', 'метод', 'анализ', 'расследование'],
        'watson': ['ватсон', 'доктор', 'помощник', 'компаньон'],
        'location': ['лондон', 'бейкер-стрит', 'дом', 'адрес', 'кабинет'],
        'music': ['скрипка', 'музыка', 'играть', 'концерт'],
        'drugs': ['кокаин', 'наркотик', 'привычка', 'эксперимент'],
        'elementary': ['элементарно', 'просто', 'легко', 'очевидно'],
        'weather': ['погода', 'дождь', 'солнце', 'холодно', 'тепло'],
        'time': ['время', 'часы', 'утро', 'вечер', 'ночь'],
        'food': ['еда', 'чай', 'кофе', 'завтрак', 'обед', 'ужин'],
        'clothes': ['одежда', 'шляпа', 'плащ', 'костюм', 'перчатки'],
        'transport': ['карета', 'лошадь', 'поезд', 'корабль', 'экипаж']
    }
    
    # Определяем тип вопроса
    question_type = None
    for key, words in keywords.items():
        if any(word in question_lower for word in words):
            question_type = key
            break
    
    # Генерируем ответы в зависимости от типа вопроса
    if question_type == 'greeting':
        responses = [
            "Добро пожаловать, дорогой друг! Я Шерлок Холмс, и я готов помочь вам в расследовании. <strong>Элементарно, Ватсон!</strong>",
            "Ах, новый клиент! Добро пожаловать в мой скромный кабинет на Бейкер-стрит. Я готов применить свой дедуктивный метод к вашему делу.",
            "Приветствую! Шерлок Холмс к вашим услугам. Расскажите мне о загадке, которая требует моего внимания.",
            "Добро пожаловать! Я готов применить свой дедуктивный метод к вашему случаю."
        ]
    
    elif question_type == 'status':
        responses = [
            "Превосходно, мой дорогой друг! Мой ум работает как часы, а дедуктивные способности находятся на пике формы. Готов к новым загадкам!",
            "Отлично! Только что завершил интересное дело с исчезновением драгоценностей. Мой метод снова доказал свою эффективность.",
            "Великолепно! Мой скрипичный концерт сегодня утром был особенно вдохновляющим. Готов к новым вызовам!",
            "Превосходно! Мой дедуктивный метод жаждет новых применений."
        ]
    
    elif question_type == 'identity':
        responses = [
            "Я Шерлок Холмс, детектив-консультант с Бейкер-стрит, 221Б. Мой дедуктивный метод позволяет мне замечать то, что упускают другие. <em>Когда ты исключишь невозможное, то, что остается, и есть правда, как бы невероятно это ни казалось.</em>",
            "Шерлок Холмс, детектив-консультант. Мой метод основан на наблюдении и дедукции. Я живу на Бейкер-стрит, 221Б, где принимаю клиентов и провожу свои расследования.",
            "Я - Шерлок Холмс, и моя профессия - детектив-консультант. Мой дедуктивный метод уникален, и я горжусь тем, что могу помочь в самых сложных случаях."
        ]
    
    elif question_type == 'help':
        responses = [
            "Мои возможности включают: <strong>дедуктивный анализ</strong>, <strong>веб-скрапинг</strong>, <strong>RAG систему</strong> для поиска информации, и, конечно же, <em>викторианский стиль речи</em>. Предоставьте мне URL для анализа или задайте вопрос!",
            "Я специализируюсь на дедуктивном анализе, веб-скрапинге и поиске информации. Мой метод позволяет находить связи там, где другие видят только хаос.",
            "Мои инструменты: острый ум, дедуктивный метод, способность к веб-скрапингу и анализу данных. Готов применить их к вашему делу!"
        ]
    
    elif question_type == 'mystery':
        responses = [
            "Интересно! Расскажите мне подробности этой загадки. Помните, <strong>детали имеют значение</strong>. Каждый факт может быть ключом к разгадке.",
            "Хм, интригующая проблема! Мой дедуктивный метод жаждет применения. Расскажите все, что знаете, даже самые незначительные детали.",
            "Отлично! Новое дело для моего метода. Каждый элемент может быть решающим. Поделитесь всеми фактами."
        ]
    
    elif question_type == 'method':
        responses = [
            "Мой дедуктивный метод основан на наблюдении и логике. <em>Вы видите, но не наблюдаете</em>. Я замечаю мельчайшие детали, которые другие упускают, и соединяю их в логическую цепочку.",
            "Дедукция - это искусство логического вывода. Я исключаю невозможное, и то, что остается, каким бы невероятным оно ни казалось, должно быть правдой.",
            "Мой метод прост: наблюдение, анализ, дедукция. Я замечаю то, что другие пропускают, и соединяю факты в единую картину."
        ]
    
    elif question_type == 'watson':
        responses = [
            "Ах, мой дорогой Ватсон! Мой верный друг и помощник. Хотя он иногда не понимает моих методов, его присутствие и записи наших дел бесценны для истории криминалистики.",
            "Доктор Ватсон - мой незаменимый компаньон. Его медицинские знания и способность к наблюдению часто дополняют мой дедуктивный метод.",
            "Ватсон - не просто мой друг, но и мой летописец. Без его записей многие из моих дел были бы забыты."
        ]
    
    elif question_type == 'location':
        responses = [
            "Да, я живу на Бейкер-стрит, 221Б, в Лондоне. Мой дом - это не просто жилище, это центр моих расследований. Здесь я играю на скрипке, провожу химические эксперименты и принимаю клиентов.",
            "Бейкер-стрит, 221Б - мой дом и офис. Здесь я принимаю клиентов, провожу эксперименты и размышляю над сложными случаями.",
            "Мой адрес: Бейкер-стрит, 221Б, Лондон. Это место, где рождаются решения самых сложных загадок."
        ]
    
    elif question_type == 'music':
        responses = [
            "Музыка помогает мне думать, мой дорогой друг. Когда я играю на скрипке, мой ум может сосредоточиться на самых сложных загадках. Это как медитация для дедуктивного мышления.",
            "Скрипка - мой верный спутник в размышлениях. Мелодии помогают упорядочить мысли и найти решение в самых запутанных делах.",
            "Музыка и дедукция идут рука об руку. Моя скрипка помогает мне сосредоточиться на деталях, которые упускают другие."
        ]
    
    elif question_type == 'drugs':
        responses = [
            "Хм, вы говорите о моих... экспериментах. Да, я иногда использую кокаин для стимуляции ума, когда нет интересных дел. Но это не влияет на мои дедуктивные способности.",
            "Мои эксперименты с кокаином - это способ борьбы с скукой между делами. Но когда появляется интересная загадка, я полностью сосредоточен на ней.",
            "Да, я признаю свою привычку. Но она не мешает моей работе - скорее, помогает справиться с периодами бездействия."
        ]
    
    elif question_type == 'elementary':
        responses = [
            "<strong>Элементарно, мой дорогой Ватсон!</strong> Когда вы исключите невозможное, то, что остается, и есть правда.",
            "Элементарно! Простое наблюдение и логика - вот ключ к решению любой загадки.",
            "Элементарно, Ватсон! Дедуктивный метод никогда не подводит."
        ]
    
    elif question_type == 'weather':
        responses = [
            "Погода в Лондоне часто бывает туманной, что создает идеальную атмосферу для моих расследований. Туман скрывает детали, но не от моего дедуктивного метода.",
            "Лондонская погода - это отдельная загадка! Но она не мешает моим расследованиям. Каждая деталь важна, даже капли дождя на окне.",
            "Погода влияет на улики, мой дорогой друг. Дождь может смыть следы, но не может скрыть логику дедукции."
        ]
    
    elif question_type == 'time':
        responses = [
            "Время - это важный элемент в любом расследовании. Хронология событий часто является ключом к разгадке.",
            "Время не ждет, мой дорогой друг. Каждая минута может быть решающей в расследовании.",
            "Время - это фактор, который я всегда учитываю в своих дедуктивных выводах."
        ]
    
    elif question_type == 'food':
        responses = [
            "Чай - это не просто напиток, это ритуал размышлений. Чашка горячего чая помогает мне сосредоточиться на деталях.",
            "Еда - это необходимость, но мой ум часто слишком занят расследованием, чтобы думать о таких мелочах.",
            "Чай и размышления идут рука об руку в моем кабинете на Бейкер-стрит."
        ]
    
    elif question_type == 'clothes':
        responses = [
            "Одежда может многое рассказать о человеке, мой дорогой друг. Качество ткани, состояние, стиль - все это важные детали для дедукции.",
            "Мой костюм и шляпа - это не просто одежда, это часть моего образа детектива-консультанта.",
            "В одежде человека скрыто множество улик. Я всегда обращаю внимание на такие детали."
        ]
    
    elif question_type == 'transport':
        responses = [
            "Средства передвижения оставляют следы, мой дорогой друг. Колеса кареты, копыта лошадей - все это может быть важной уликой.",
            "Транспорт - это важный элемент в расследовании. Он может рассказать о маршруте преступника.",
            "Каждый вид транспорта оставляет свои уникальные следы. Это важная часть дедуктивного анализа."
        ]
    
    elif context and len(context) > 10:
        # Если есть контекст из веб-скрапинга
        responses = [
            f"Интересно! Основываясь на проанализированной информации, я могу сказать следующее: <strong>контекст был успешно извлечен</strong>. Теперь я могу отвечать на вопросы, используя эти данные. Что именно вас интересует?",
            f"Отлично! Я изучил предоставленную информацию. <strong>Данные проанализированы</strong> и готовы к использованию. Задавайте вопросы!",
            f"Превосходно! Информация обработана моим дедуктивным методом. <strong>Контекст готов</strong> для дальнейшего анализа."
        ]
    
    else:
        # Общий ответ с большим разнообразием
        responses = [
            "Хм, интересное наблюдение, мой дорогой друг. Позвольте мне применить свой дедуктивный метод к этому вопросу.",
            "Элементарно! Хотя, возможно, не совсем. Давайте разберем это по порядку.",
            "Интересная загадка! Мой ум уже работает над решением.",
            "Позвольте мне проанализировать эту ситуацию с помощью логики и наблюдения.",
            "Хм, это требует более глубокого анализа. Мой дедуктивный метод в действии!",
            "Интересно! Каждый факт может быть ключом к разгадке. Расскажите больше.",
            "Мой дорогой Ватсон, это классический случай для применения дедуктивного метода!",
            "Позвольте мне применить свой метод: <em>когда ты исключишь невозможное, то, что остается, и есть правда</em>.",
            "Хм, интригующая проблема! Мой дедуктивный метод жаждет применения.",
            "Интересное наблюдение! Позвольте мне применить логику к этому вопросу.",
            "Хм, это требует моего внимания. Дедуктивный метод в действии!",
            "Отлично! Новый вызов для моего метода. Расскажите подробнее.",
            "Интересная загадка! Мой ум уже анализирует возможные решения.",
            "Хм, это классический случай для дедуктивного анализа.",
            "Позвольте мне применить свой метод к этой проблеме.",
            "Интересно! Мой дедуктивный метод готов к работе.",
            "Хм, это требует моего внимания. Расскажите подробнее.",
            "Отлично! Новый случай для анализа.",
            "Интересная проблема! Мой метод в действии.",
            "Хм, это классический случай для дедукции."
        ]
    
    import random
    return random.choice(responses)

def scrape_website(url):
    """Скрапинг веб-страницы"""
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Удаляем скрипты и стили
        for script in soup(["script", "style"]):
            script.decompose()
        
        # Извлекаем текст
        text = soup.get_text()
        
        # Очищаем текст
        lines = (line.strip() for line in text.splitlines())
        chunks = (phrase.strip() for line in lines for phrase in line.split("  "))
        text = ' '.join(chunk for chunk in chunks if chunk)
        
        return {
            'url': url,
            'title': soup.title.string if soup.title else url,
            'content': text[:2000],  # Ограничиваем размер
            'timestamp': datetime.now().isoformat()
        }
        
    except Exception as e:
        print(f"Ошибка скрапинга: {e}")
        return None

def find_relevant_context(question, top_k=3):
    """Поиск релевантного контекста для RAG (упрощенная версия)"""
    if not scraped_content:
        return ""
    
    try:
        # Простой поиск по ключевым словам
        question_lower = question.lower()
        relevant_chunks = []
        
        for content in scraped_content:
            content_lower = content['content'].lower()
            
            # Ищем совпадения слов
            question_words = set(question_lower.split())
            content_words = set(content_lower.split())
            
            # Вычисляем пересечение
            common_words = question_words.intersection(content_words)
            relevance_score = len(common_words) / len(question_words) if question_words else 0
            
            if relevance_score > 0.1:  # Порог релевантности
                relevant_chunks.append((relevance_score, content['content'][:500]))
        
        # Сортируем по релевантности
        relevant_chunks.sort(reverse=True)
        
        # Возвращаем топ контекст
        relevant_context = "\n".join([text for _, text in relevant_chunks[:top_k]])
        return relevant_context
        
    except Exception as e:
        print(f"Ошибка поиска контекста: {e}")
        return ""

@app.route('/')
def index():
    return render_template('huggingchat.html')

@app.route('/chat', methods=['POST'])
def chat():
    try:
        data = request.get_json()
        message = data.get('message', '').strip()
        
        if not message:
            return jsonify({'error': 'Сообщение не может быть пустым'})
        
        # Поиск релевантного контекста
        context = find_relevant_context(message)
        
        # Генерация ответа
        response = generate_response(message, context)
        
        return jsonify({
            'response': response,
            'timestamp': datetime.now().strftime('%H:%M:%S')
        })
        
    except Exception as e:
        print(f"Ошибка чата: {e}")
        return jsonify({'error': 'Произошла ошибка при обработке запроса'})

@app.route('/scrape', methods=['POST'])
def scrape():
    try:
        data = request.get_json()
        url = data.get('url', '').strip()
        
        if not url:
            return jsonify({'error': 'URL не может быть пустым'})
        
        # Скрапинг веб-страницы
        scraped_data = scrape_website(url)
        
        if scraped_data:
            # Добавляем в глобальный список
            scraped_content.append(scraped_data)
            
            return jsonify({
                'success': True,
                'message': f'Сайт {url} успешно проанализирован! Добавлено {len(scraped_data["content"])} символов текста.',
                'title': scraped_data['title'],
                'timestamp': scraped_data['timestamp']
            })
        else:
            return jsonify({'error': 'Не удалось обработать указанный URL'})
        
    except Exception as e:
        print(f"Ошибка скрапинга: {e}")
        return jsonify({'error': 'Произошла ошибка при обработке URL'})

@app.route('/status')
def status():
    """Статус системы"""
    return jsonify({
        'status': 'running',
        'model': 'HuggingChat Integration + Fallback',
        'scraped_sites': len(scraped_content),
        'huggingchat_url': HUGGINGCHAT_URL
    })

if __name__ == '__main__':
    print("🤖 Запуск AI-бота Шерлока Холмса с HuggingChat интеграцией...")
    print("🚀 Запуск веб-сервера...")
    app.run(host='0.0.0.0', port=5000, debug=True) 